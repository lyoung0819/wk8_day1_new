{
    "cells": [
        {
            "language": "markdown",
            "source": [
                "[Intro To TS](#intro)<br>\n&emsp;[JS Built-in Types](#built)<br>\n&emsp;[Declaration](#declare)<br>\n&emsp;[Exercise #1](#ice1)<br>\n&emsp;[Implicit Types](#itype)<br>\n&emsp;[Arrays](#array)<br>\n&emsp;[Exercise #2](#ice2)<br>\n&emsp;[Exercise #3](#ice3)<br>\n&emsp;[Functions](#func)<br>\n&emsp;&emsp;[Return](#return)<br>\n&emsp;&emsp;[Exercise #4](#ice4)<br>\n&emsp;&emsp;[Arrow Functions](#arrow)<br>\n&emsp;&emsp;[Exercise #5](#ice5)<br>\n&emsp;&emsp;[Void](#void)<br>\n&emsp;&emsp;[Exercise #6](#ice6)<br>\n&emsp;[TS Built-in Types](#tstypes)<br>\n&emsp;&emsp;[any](#any)<br>\n&emsp;&emsp;[Exercise #7](#ice7)<br>\n&emsp;&emsp;[Tuple](#tuple)<br>\n&emsp;&emsp;[Exercise #8](#ice8)<br>\n&emsp;&emsp;[Enum](#enum)<br>\n&emsp;&emsp;[Exercise #9](#ice9)<br>\n&emsp;&emsp;[Unknown](#unknown)<br>\n&emsp;&emsp;[Type Guards](#guard)<br>\n&emsp;&emsp;[Exercise #10](#ice10)<br>\n&emsp;&emsp;[never](#never)<br>\n&emsp;[Objects](#obj)<br>\n&emsp;&emsp;[Exercise #11](#ice11)<br>\n&emsp;&emsp;[Type Alias](#type)<br>\n&emsp;&emsp;[Exercise #12](#ice12)<br>\n&emsp;&emsp;[readonly](#readonly)<br>\n&emsp;&emsp;[Optional Chaining](#opt)<br>\n&emsp;&emsp;[Objects with Methods](#objmeth)<br>\n&emsp;&emsp;[Exercise #13](#ice13)<br>\n&emsp;&emsp;[Union Types](#union)<br>\n&emsp;&emsp;[Exercise #14](#ice14)<br>\n&emsp;[as Keyword](#as)<br>\n&emsp;[Intersection Types](#intersec)<br>\n&emsp;[Exercise #15](#ice15)<br>\n&emsp;[Literal Types](#literal)<br>\n&emsp;[Exercise #16](#ice16)<br>\n&emsp;[Non-null assertion operator](#nnao)<br>\n&emsp;[Homework](#hw)<br>\n"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "<a id=\"intro\"></a>\n# Intro To TypeScript"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "TypeScript was developed in 2012 by Microsoft. As of Early 2023 the most current TypeScript version is 4.9, with 5.0 being in beta. (This notebook uses 4.1) TypeScript is what’s called a superset of JavaScript, meaning it encompasses everything that is JavaScript and it includes even more features.\n\nTypescript’s main feature is that it adds static typing to Vanilla JS.  JavaScript (and python) are called dynamically type languages, this means the data type of the variables isn't determined until runtime.  This is a recipe for disaster in complex applications.  When working with a dynamically typed language the errors don't show up until you try using your program and something goes wrong.  This makes finding and preventing errors a hassle.  Enter TypeScript, with a statically type language (like C++/Java/C#) the datatypes of the variables are declared and known at compile time (or before you actually run the program.)  That means, when you go to compile your code, you will get errors before ever running the program.  This also helps the itellisense (how VSCode or Jupyter Notebook gives you hints on methods and properties) know what options to give.  This makes the programmers life much easier.\n\nWhen you write a TypeScript (.ts) file you must compile that TS code.  The TS code is read by your computer and it compiles the TS code into new JavaScript files (.js).  This is the compilation step that will give you the type checking errors.  Once it is compiled into JS you can run the JS file like any other JS file.  You will also get a TS config file, in where, you can specify lots of rules that can change how TS checks your TS files. When working in Jupyter Notebook with the TS kernel, you won't see this compilation step however it is happening in the background.\n"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "<a id=\"built\"></a>\n\n## Built-in Types"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "JavaScript has seven built-in types: <b>null</b> , <b>undefined</b> , <b>boolean</b> , <b>number</b> , <b>string</b> , <b>object</b> , and <b>symbol</b> \n\nYou should know these types already, except for symbol (don't worry about symbol)"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "<a id=\"declare\"></a>\n\n### Declaring"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "When declaring a variable you can set its type explicitly by adding a `:` then the name of the class.\n\n<b>Note:</b> The types are lower cased, Number and number and Boolean and boolean are not the same and will cause issues"
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "\n// something called anyType with is a big no no\n// arming our cariables aka not setting them to values but just declaring them\n\nlet anyType \nlet typeString: string\nlet typeNumber: number\nlet typeBoolean: boolean\nlet typeObj: object\nlet typeNull: null\nlet typeUndefined: undefined // we don't really ever declare this guy. "
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "Without a type annotation we can reassign `anyType` to any type of variable"
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "anyType = 'firebends rule' // string\nanyType = 4 // number\n\n// This won't give an error, but this defeats the purpose of TypeScript \n"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "text/plain",
                            "value": [
                                "\u001b[33m4\u001b[39m"
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "language": "typescript",
            "source": [
                "typeString = 123 //Error"
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "typeString = \"please don't be mad at me i am a string now\""
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "text/plain",
                            "value": [
                                "\u001b[32m\"please don't be mad at me i am a string now\"\u001b[39m"
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "language": "typescript",
            "source": [
                "typeObj = 'Can I make this a string' //Error"
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "typeObj = {id: 1, name: 'Travis'}"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "text/plain",
                            "value": [
                                "{",
                                "  id: \u001b[33m1\u001b[39m,",
                                "  name: \u001b[32m'Travis'\u001b[39m",
                                "}"
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "language": "markdown",
            "source": [
                "<a id=\"ice1\"></a>\n\n## In-Class Exercise #1"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "In the cells provided declare 3 variables `iceString` of type string `iceNumber` of type number `iceBool` of type boolean\nThen on seperate line assign those variables values of an appropriate type"
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "// This is delcaring typesEXPLICITY \n\nlet iceString: string\nlet iceNumber: number\nlet iceBool: boolean\n\n\niceString = 'Avatar Live Action was kinda mid, I\\'m sorry unpopular opinion maybe'\niceNumber = 2323546345\niceBool = true\n"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "<a id=\"itype\"></a>\n\n## Implicit Type Declaration"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "When you declare and intialize a variable with TypeScript, it will implicitly add the type declaration for you"
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "// If we don't explicitly state the type, it will infer based on the value\n\nlet implicitType = [\"Aang\", \"Katara\", \"Zuko\", \"Saka\"]\n"
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "implicitType = \"Lets try to reassign to a string\" // it is mad at us, typeString is not assignle to type array of strings (it gathered this from the value above)\n"
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "implicitType = [\"Uncle Iroh\", 2] // error only at the point in time where the type changes! (2) "
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "The above example shows the `implicitlyTypedArray` was not declared to as an array (of strings) but TypeScript implicitly typed it based on the initial state of  `[\"Na na na na\", \"na na na na\",\"hey hey\", \"Goodbye\"]`"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "<a id=\"array\"></a>\n\n## Array typing"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "Arrays in TS need to be type set to an array, but not just and array, and arrays must declare the datatype of its member elements.  To do this we add the datatype of the elements in the array followed by `[]`.  Typically we only put the same datatype in an array."
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "// you need to assign what is going to be in the array\nlet explicitTypeArray: number[] // saying this will be an array of numbers"
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "explicitTypeArray = [1, 5, 6, 95] // all good\nexplicitTypeArray = ['Howdy', 1, 5, 7, 2] // its mad at the non-number piece of the array"
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                ""
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "<a id=\"ice2\"></a>\n\n## In-Class Exercise #2"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "Create an array of nulls using explicit type checking called `arrayOfNulls`"
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "\nlet arrayOfNulls : null[]\narrayOfNulls = [null, null]\n"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "#### Multiple Datatypes in Array"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "We usually avoid putting multiple data types in an array if there is more than 2 elements because it gets hard to read and use.  If we want to do this we put inside bracket we state the datatype for each index of the array like so\n\n`let myVar:[datatypeOfIndex0, datatypeOfIndex1, datatypeOfIndex2, datatypeOfIndex3, ..ect]`"
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "let multipleTpeArray: [number, string, boolean, null]"
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "multipleTpeArray = [1, 'hello', true, null]"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "text/plain",
                            "value": [
                                "[",
                                "  \u001b[33m1\u001b[39m,",
                                "  \u001b[32m'hello'\u001b[39m,",
                                "  \u001b[33mtrue\u001b[39m,",
                                "  \u001b[1mnull\u001b[22m",
                                "]"
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "language": "markdown",
            "source": [
                "The Order of the elements is critical"
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "// It will error if you do not have the correct value types"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "#### Multiple elements of unknown Length"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "What if the array's first element is a string and then we have an unknown about of numbers?\n\nWe will use the spread operator to say the second member of the array is an unpacked number array"
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "// the ... (spread operator) aka its greedy, its going to grab whatever we place inside this array and deconstruct it\nlet unknownLengthArray: [string, ...number[]]"
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "unknownLengthArray = ['Travis', 3, 5, 2, 5, 2, 4, 2, 5, 3, 7, 8, 4]"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "text/plain",
                            "value": [
                                "[",
                                "  \u001b[32m'Travis'\u001b[39m,",
                                "  \u001b[33m3\u001b[39m,",
                                "  \u001b[33m5\u001b[39m,",
                                "  \u001b[33m2\u001b[39m,",
                                "  \u001b[33m5\u001b[39m,",
                                "  \u001b[33m2\u001b[39m,",
                                "  \u001b[33m4\u001b[39m,",
                                "  \u001b[33m2\u001b[39m,",
                                "  \u001b[33m5\u001b[39m,",
                                "  \u001b[33m3\u001b[39m,",
                                "  \u001b[33m7\u001b[39m,",
                                "  \u001b[33m8\u001b[39m,",
                                "  \u001b[33m4\u001b[39m",
                                "]"
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "language": "markdown",
            "source": [
                "<strong>Note:</strong> This style means there could also be nothing in our unpacked number array, so the second index becomes optional"
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "// the spread operator ... is very similar to *args in Python oft the * in regex... it grabs one to many\n\nunknownLengthArray = ['Travis', 3, 5, 2, 5, 2, 4, 2, 5, 3, 7, 8, 4]"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "<a id=\"ice3\"></a>\n\n## In-Class Exercise #3"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "Create an array that starts with one string and then can hold any number of booleans and name it `stringBoolsArray` and assign it some values"
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "\nlet stringBoolsArray: [string, ...boolean[]]\n\nstringBoolsArray = ['hello', true, true, false, false, true, false, true, true]"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "text/plain",
                            "value": [
                                "[",
                                "  \u001b[32m'hello'\u001b[39m,",
                                "  \u001b[33mtrue\u001b[39m,",
                                "  \u001b[33mtrue\u001b[39m,",
                                "  \u001b[33mfalse\u001b[39m,",
                                "  \u001b[33mfalse\u001b[39m,",
                                "  \u001b[33mtrue\u001b[39m,",
                                "  \u001b[33mfalse\u001b[39m,",
                                "  \u001b[33mtrue\u001b[39m,",
                                "  \u001b[33mtrue\u001b[39m",
                                "]"
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "language": "markdown",
            "source": [
                "<a id=\"func\"></a>\n\n## TS and Intellisense, and Functions"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "Typescript helps you with itellisense.  In Jupyter notebook you can press tab after writing a dot to see the available methods.  This only works if the itellisense can determine what the datatype of the variable is.  Typescript introduces static typing to JS, so when using proper TS techniques the itellisense will know the type of data being past.\n\nConsider the examples below.  The first example is without static type checking.  note when you type `name.` and press `tab` you get no suggestions; This tells you that the compiler does not know the type of the name variable.\n\nLooking at the second example we annotate the name parameter to be of type string, now when you press tab after the `name.` you will see a list of availible string methods and properties.\n"
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "// function without TS superpowers\nfunction nameLower(name){\n    name = name.toLowerCase();\n    return name;    \n}\n\nnameLower('ALEX');"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "text/plain",
                            "value": [
                                "\u001b[32m'alex'\u001b[39m"
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "language": "typescript",
            "source": [
                "// function WITH TS superpowers\n\nfunction nameLower(name:string){\n    name = name.toLowerCase();\n    return name\n}\n\nnameLower('traVIS')"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "text/plain",
                            "value": [
                                "\u001b[32m'travis'\u001b[39m"
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "language": "markdown",
            "source": [
                "<a id=\"return\"></a>\n\n## Declaring a Return Type"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "Now lets use the returned string with and without return type annonations."
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "Using the same example we will see that the compiler knows the data type of name, once again we can easily verify this my trying the tab key."
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "// No return type\nfunction nameUpper(name:string){\n    return name.toUpperCase();\n}\n\n\nnameUpper('tRavIs')\n\n"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "text/plain",
                            "value": [
                                "\u001b[32m'TRAVIS'\u001b[39m"
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "language": "markdown",
            "source": [
                "The compiler knows this is a string because we passed in a string and didn't do anything that may change its data type"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "Let's try to confuse the compilier by adding an integer to our string.  This will cause the compiler not to know what the data type of our return is, once again we can test by press tab after the dot"
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "// No return type\nfunction nameUpper(name:string){\n    name = name.toUpperCase();\n    return name + 2\n}\n\n\nnameUpper('tRavIs')\n"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "text/plain",
                            "value": [
                                "\u001b[32m'TRAVIS2'\u001b[39m"
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "language": "markdown",
            "source": [
                "#### Explicit Return Type"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "Lets annotate the return type of this function, we will see now the compiler and our itellisense knows the return of the function is a string\n\nTo annotate a return type on a regular function it looks like:\n```\nfunction funcName(params):ReturnType{}\n```"
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "// return type of string\n//syntax:\n// function functionName(param:paramType):returnType{..code to run} \n\nfunction nameUpper(name:string):string{\n    return name.toUpperCase();\n}\n\n\nnameUpper('tRavIs').length\n\n\n\n\n"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "text/plain",
                            "value": [
                                "\u001b[33m6\u001b[39m"
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "language": "markdown",
            "source": [
                "<a id=\"ice4\"></a>\n\n## In-Class Exercise #4"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "Create a regular function that takes in two numbers and returns a string that says.\n```[firstnumber] plus [secondNumber] equals [FirstNumber plus SecondNumber]```\n\nName the function `iceAddition`\n\nif we run `iceAddition(2,5)`\n\nthe output should be :\n\n```\n\"2 plus 5 equals 7\"\n```\n\nUse Explicit type checking on the parameters and return type"
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "\nfunction iceAddition(num1:number, num2:number):string{\n    return `${num1} plus ${num2} equals ${num1 + num2}`\n}\n\niceAddition(4, 5)"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "text/plain",
                            "value": [
                                "\u001b[32m'4 plus 5 equals 9'\u001b[39m"
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "language": "markdown",
            "source": [
                "<a id=\"arrow\"></a>\n\n## Arrow Functions"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "To annotate a return type on an arrow function it looks like:\n```\nconst funcName=(params):ReturnType=>{}\n```"
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "// Syntax: \n// const functionName = () => {}\n\nconst nameUpper2 = (name:string):string => {\n    return name.toUpperCase();\n}\n\nnameUpper2('Connor');"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "text/plain",
                            "value": [
                                "\u001b[32m'CONNOR'\u001b[39m"
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "language": "markdown",
            "source": [
                "<a id=\"ice5\"></a>\n\n## In-Class Exercise #5"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "Create an Arrow function that takes in two numbers and returns a string that says.\n```[firstnumber] plus [secondNumber] equals [FirstNumber plus SecondNumber]```\n\nName the function `iceAdditionArrow`\n\nif we run `iceAdditionArrow(2,5)`\n\nthe output should be :\n\n```\n\"2 plus 5 equals 7\"\n```\n\nUse Explicit type checking on the parameters and return type"
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "\nconst iceAdditionArrow = (num1: number, num2: number):string => {\n    return `${num1} plus ${num2} equals ${num1 + num2}`\n}\niceAdditionArrow(4, 6)\n\n"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "text/plain",
                            "value": [
                                "\u001b[32m'4 plus 6 equals 10'\u001b[39m"
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "language": "markdown",
            "source": [
                "<a id=\"void\"></a>\n\n### Void Type"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "Often our function returns nothing, for this we can use the void type.  The term void to represent function without returns is ubiquitous in all languages.\n\nNote: returning `null` or `undefined` statisfies void "
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "// void means there will be no return type\nconst doSomething = (num: number, exponential: number):void => {\n    console.log(num ** exponential)\n}\n\n// you can do anything BUT use return\n\nlet myVar = doSomething(4, 4)\nconsole.log(myVar); // there is no return to save to a variable, so this will show undefined \n"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "application/vnd.code.notebook.stdout",
                            "value": [
                                "256",
                                "undefined",
                                ""
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "language": "typescript",
            "source": [
                "\nconst returnSomething = (name:string):void => {\n    return name.startsWith('A'); // error\n}\n\nreturnSomething('Adonai')\n\n\n"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "text/plain",
                            "value": [
                                "\u001b[33mtrue\u001b[39m"
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "language": "markdown",
            "source": [
                "<a id=\"ice6\"></a>\n\n## In-Class Exercise #6"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "Create an arrow function that is named `iceVoid` and have that function print:\n\n`If I have a void I have nothing`\n\nBe sure to explicity type the function's return"
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "\n/// ----------------"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "<a id=\"tstypes\"></a>\n\n## TypeScript Built in Types"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "We have already mentioned JavaScript has seven built-in types: <b>null</b> , <b>undefined</b> , <b>boolean</b> , <b>number</b> , <b>string</b> , <b>object</b> , and <b>symbol</b> \n\nTypeScript adds to these types with: <b>unknown</b>, <b>any</b>, <b>tuple</b>, <b>enum</b>,<b> never</b> and more.\n\nReference: [https://www.typescriptlang.org/docs/handbook/2/everyday-types.html]('https://www.typescriptlang.org/docs/handbook/2/everyday-types.html')"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "<a id=\"any\"></a>\n\n### any type"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "The any type means that the data can belong to any datatype.  Be very careful when using this datatype; it should be avoided at all costs.  Using the any type, may make your code easier to write, but you will lose all benefits of TypeScript.\n\nWhen you don't explicitly declare a type to a variable TS will implicitly assign it to any."
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "// ^^ primitive(not data holding) : null, undefined, boolean, number, string\n// -------------------\n\n// Always try to avoid the any type, but it defeats the point of TypeScript\nlet typeAny: any;\ntypeAny = 123\ntypeAny = 'abc'\ntypeAny = ['hello', 5, true, false]\n"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "<a id=\"ice7\"></a>\n\n## In-Class Exercise #7"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "In the cell below write `I will not use the any type unless absolutely necessary`"
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "// I will not use the any type unless absolutely necessary "
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "<a id=\"tuples\"></a>\n\n### Tuples"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "A Tuple is a fixed length array where each element has a particular type.\nThese are generally used for arrays with only 2 pieces of information, as they quickly become hard to read and manage."
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "let myTuple: [number, string] //this is acting like a Tuple even thought its an array\nmyTuple = [1, 'Blue Nike Shoes']\n"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "text/plain",
                            "value": [
                                "[",
                                "  \u001b[33m1\u001b[39m,",
                                "  \u001b[32m'Blue Nike Shoes'\u001b[39m",
                                "]"
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "language": "typescript",
            "source": [
                "//Error\nmyTuple = [1, 'Blue Nike Shoes', 'in good condition']"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "### ⚠️WARNING⚠️"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "TypeScript isn't perfect when working with tuples and the push method will work, but this goes against the TS principlas and should never be done."
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "// this works but shouldn't!!!\nmyTuple.push('in good condition') // This works... It SHOULD NOT, but it is\nconsole.log(myTuple)"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "application/vnd.code.notebook.stdout",
                            "value": [
                                "[ 1, 'Blue Nike Shoes', 'in good condition' ]",
                                ""
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "language": "markdown",
            "source": [
                "<a id=\"ice8\"></a>\n\n## In-Class Exercise #8"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "Create an appropriate tuple named `iceTuple` that contains the values `true` `undefined`"
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "\nlet iceTuple = [true, undefined]"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "<a id=\"enum\"></a>\n\n### Enum Type"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "Enums are used when there are highly related constants.\n\nTo create an enum we use the syntax\n\n`enum NameOfEnum {key, key, key}`\n\n<b>Note: </b> Notice there is no equal sign\n\nEnums should be named using PascalCase\n\nBy default each member of the enums value will be the index position of that value (starts at 0)"
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "\n// if we don't provide a value, it will take the index \n\n// enum Size{Small, Medium, Large}\n//  console.log(Size.Small); // 0 (because its the 0 index)"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "application/vnd.code.notebook.stdout",
                            "value": [
                                "6",
                                ""
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "language": "markdown",
            "source": [
                "We can start at a different number other than 0 by setting a number on the first element.  The following elements value with be incremented by one"
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "// enum Size{Small=5, Medium, Large}\n// console.log(Size.Medium) // 6 - it auto-increments!\n"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "#### Explicitly setting enum values"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "We can explicitly set the enum values to other types, but when we do this we must assign every single element a value. "
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "\nenum Size{Small='S', Medium='M', Large='L'}\nconsole.log(Size.Medium)\n\n// very useful type when you have data reusing over and over and over again like Error Handling! \nenum Errors {Payment='Your payment didnt go through', User='Could not find user of that name'}\nconsole.log(Errors.Payment)\n\n"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "application/vnd.code.notebook.stdout",
                            "value": [
                                "M",
                                "Your payment didnt go through",
                                ""
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "language": "markdown",
            "source": [
                "<a id=\"ice9\"></a>\n\n## In-Class Exercise #9"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "Create an enum type to represent The different football teams that can be on the field.\n\n`offense` `defense` and `specialTeams`\n\nThey should be represented by `O`,`D`, and `ST` respectively\n\nname the enum `IceEnum`\n\nuse the Ice Enum to print `ST O D`"
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "// New to us with TypeScript\nenum Teams{O='Offense', D='Defense', ST=\"Speacial Teams\"}\nconsole.log(Teams.O)\nconsole.log(Teams.D)\nconsole.log(Teams.ST)\n"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "application/vnd.code.notebook.stdout",
                            "value": [
                                "Offense",
                                "Defense",
                                "Speacial Teams",
                                ""
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "language": "markdown",
            "source": [
                "<a id=\"unknown\"></a>\n\n### Unknown Type"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "The Unknown type is similar to the any type, but it will enforce type checking.  In order to use an Unknown type we must use a Type Guard to perform narrowing."
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "#### With any"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "We see here no compilation error, yet the person parameter has no guarentee it has the abilities to walk and talk"
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "// New to us with TypeScript\n\n//Allows different types but it always trying to narrow down what type it is\n\nfunction myUnknownFunction(person:any){\n    person.walk();\n    person.talk();\n}\n\nmyUnknownFunction({'name': 'Travis', 'cool': true})\n"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "application/vnd.code.notebook.error",
                            "value": {
                                "name": "TypeError",
                                "message": "person.walk is not a function",
                                "stack": "    at myUnknownFunction (<Cell 110> [6, 10])\n    at <Cell 110> [10, 17]\n    at <Cell 110> [8, 46]\n    at Script.runInContext (node:vm:148:12)\n    at Script.runInNewContext (node:vm:153:17)\n    at Object.runInNewContext (node:vm:309:38)\n    at C (/Users/alexandriayoung/.vscode/extensions/donjayamanne.typescript-notebook-2.0.6/out/extension/server/index.js:2:113345)\n    at t.execCode (/Users/alexandriayoung/.vscode/extensions/donjayamanne.typescript-notebook-2.0.6/out/extension/server/index.js:2:114312)\n    at k.<anonymous> (/Users/alexandriayoung/.vscode/extensions/donjayamanne.typescript-notebook-2.0.6/out/extension/server/index.js:2:142156)\n    at k.emit (node:events:518:28)"
                            }
                        }
                    ]
                }
            ]
        },
        {
            "language": "markdown",
            "source": [
                "#### With Unknown"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "The person parameter is now annotated as unknown and we see we get a compilation error when trying to use this code"
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "function myUnknownFunction(person:unknown){\n    person.walk();\n    person.talk() // aka - we don't know if we can call the talk() method to this unknown type \n}\n// TypeScript is always trying to help you catch errors before you get in the weeds "
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "<a id=\"guard\"></a>\n\n#### Type Narrowing"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "To be able to use the unknown type we must first create our <b>Type Guard</b>.  This will narrow down the datatype so you can perform approiate actions.\n\n<strong>Note: </strong> This also allows the itellisense to kick in and give suggestions"
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "// Type Guarding is a fancy way of saying if conditionals\n\nclass Person {\n    walk(){\n        console.log(\"I'm Christopher Walking here\")\n    }\n    talk(){\n        console.log(\"Speaking of Christopher Walkin why the heck was he in Dune 2? That was weird right?\")\n    }\n}\n\nfunction myUnknownFunction(person:unknown):void{\n    // now I can do a check aka Type Guarding!\n    if (person instanceof Person){\n        person.walk()\n        person.talk()\n    } else {\n        console.log(\"This is not a person and can neither walk nor talk!\")\n    }\n}\n\n\nlet christopher = new Person()\n\nmyUnknownFunction(christopher)\n"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "application/vnd.code.notebook.stdout",
                            "value": [
                                "I'm Christopher Walking here",
                                "Speaking of Christopher Walkin why the heck was he in Dune 2? That was weird right?",
                                ""
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "language": "markdown",
            "source": [
                "<a id=\"ice10\"></a>\n\n## In-Class Exercise #10"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "Create a function that uses an unknown type parameter and implement a type guard.\n\n- If the parameter is a number we want the function to return the number sqaured\n\n- If the parameter is a string we want the function to return the string in uppercase letters\n\n- If the parameter is a boolean we want the function to return \"Its on\" if the boolean is true and \"Its off\" if the boolean is false\n\n- If the parameter is of any other type just return the parameter\n\nName the function `iceGuard`\n\nTest your function for all 4 use cases"
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "function iceGuard(value: unknown): number | string | boolean | unknown {\n    if (typeof value === 'number') {\n        return value * value;\n    } else if (typeof value === 'string') {\n        return value.toUpperCase(); \n    } else if (typeof value === 'boolean') {\n        return value ? \"Its on\" : \"Its off\"; \n    } else {\n        return value;\n    }\n}\n"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "<a id=\"never\"></a>\n\n## Never Type"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "This is a rarely used Type, and generally used as a return type from a function.\n\nThe never type is used to denote that a function never returns.  This means the function runs infintely, like a web server.\n\nI recommend not invoking (calling) the `myNeverFunction` as it is an in\nfinite loop and may crash your notebook.  The example is to show you the use of `never`"
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "// Never returns \n// Some sort of process happening in the background that never resolves\n\nfunction myNeverFunction(): never {\n    while (true) {\n        console.log(\"Heeeeey what's going on here\")\n    } \n};\n\n// will run over and over and over "
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "<a id=\"obj\"></a>\n\n# Objects and TS"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "Object are a built-in type from JS, but working with them in TS can be a little different we will go over a few ways to work with Objects in TS."
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "When declaring an Object TS will implictly force your object to maintain its \"shape\".  This means you can not dynamically add properties to your objects like you can in JS, and when you change a property is has to have the correct datatype.\n\nWhen we talk about the \"shape\" of an object we are talking about is keys, types, and methods."
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "// In TS, you have Primitive Types and Object Types\n\n// TypeScript won't let you keep adding additional key,val pairs\n\nlet student1 = {id:1}\n// student1.name = \"Jean\"\n\n\n//Error because name:string is not part of our shape"
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "student1.id = 2\n\nlet student2 = {id: 1, name: 'Jean'}\n\nstudent2.name = 'Caleb'"
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "let student: { id: number, name: string} // Explicity building my object shape! \n\nstudent = {\n    id: 2,\n    name: 'Otha'\n}"
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "// error\nstudent.name = true"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "<a id=\"ice11\"></a>\n\n## In-Class Exercise #11"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "Define the shape and the values for an object name `iceMan`\n\nIce man should have:\n\n- a id that is a number\n\n- a name that is a string\n\n- a wasFrozen property that is a boolean on whether or not our iceMan was ever frozen in time"
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "\nlet iceMan: {id:number, name:string, wasFrozen: boolean } = {id:3, name: 'Yetti', wasFrozen:true}\n\n\nlet iceMan2: {id:number, name:string, wasFrozen: boolean } = {id:3, name: 'Yetti', wasFrozen:true} // instead of doing this, we can make custom types!"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "<a id=\"type\"></a>\n\n## Type Aliases"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "The above way to work with objects is a bit cumbersome.  There is an easier way using a type alias, which allows you to predefine the shape and reuse this shape.\n\nThe type's name should be written in PascalCase"
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "// Making custom types aka the SHAPE of our data!\n\n// // custom type! \n// type Bender = {\n//     id: number,\n//     nation: string,\n//     power: number,\n//     name: string\n// }"
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "let katara: Bender = {id: 1, nation: 'water', power: 7, name: 'Katara'}\n// let aang: Bender = {id:2, nation:'air', power:9, name: 'Aang'}\n\n\nconsole.log(aang.id)\naang.pet = 'Appa' // error: not key of 'pet', cannot add\n"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "application/vnd.code.notebook.stdout",
                            "value": [
                                "2",
                                ""
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "language": "typescript",
            "source": [
                "type iceManType = {\n    id: number,\n    name: string,\n    wasFrozen: boolean\n}"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "<a id=\"ice12\"></a>\n\n## In-Class Exercise #12"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "Define the type for an our iceMan we made in the last example and name the type `IceManType`  Then create 3 iceMen called `iceMan1` `iceman2` and `iceMan3`.\n\nIce man should have:\n\n- a id that is a number\n\n- a name that is a string\n\n- a wasFrozen property that is a boolean on whether or not our iceMan was ever frozen in time"
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "\n\n\n\n\n\n\n\n"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "<a id=\"readonly\"></a>\n\n#### readonly"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "Sometime there are properties of an object that should never change, for instance an id should never be changed.  This rule can be enforced with the `readonly` keyword"
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "// added read-only in front of id\n\n// type Bender = {\n//     readonly id: number,\n//     nation: string,\n//     power: number,\n//     name: string\n// }\n"
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "let iroh: Bender = {id: 3, nation: 'fire', power: 8, name:'Uncle Iroh'}\n\niroh.id = 5 // error - cannot assign 5 to id because id is set as a readonly ! \n"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "<a id=\"opt\"></a>\n\n#### Optional fields"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "Sometime you also have fields that should be optional, and not required to add in, like a Fax Number or Address Line 2.  This can be denoted using the `?`"
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "// Added optional pet field\n// add '?' to end of key\n\n// type Bender = {\n//     readonly id: number,\n//     nation: string,\n//     power: number,\n//     name: string,\n//     pet?: string\n// }\n\nlet aang: Bender = {id:2, nation:'air', power:9, name: 'Aang', pet: 'Appa'}\nlet zuko: Bender = {id:5, nation:'fire', power:7, name:'Zuko', pet: 'Druk'}\n"
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "console.log(zuko.pet)\n"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "application/vnd.code.notebook.stdout",
                            "value": [
                                "Druk",
                                ""
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "language": "markdown",
            "source": [
                "<a id=\"objmeth\"></a>\n\n#### methods"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "Types can also include methods that should be implemented."
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "// finally, we can also add methods to our types!\n\ntype Bender = {\n    readonly id: number,\n    nation: string,\n    power: number,\n    name: string,\n    pet?: string\n    usePower: (power: string) => string // usePower: method that takes in a string, and will return a string\n}; \n\n"
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "let toph: Bender = {\n    id:6, \n    nation:'earth', \n    power:8,\n    name: 'Toph',\n    usePower: (power:string) => {\n        return `I will use my ${power} power to defeat you!!!`\n    }\n}\n\ntoph.usePower('rock slicer')\n\n\n\n\n\n"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "text/plain",
                            "value": [
                                "\u001b[32m'I will use my rock slicer power to defeat you!!!'\u001b[39m"
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "language": "markdown",
            "source": [
                "<a id=\"ice13\"></a>\n\n## In-Class Exercise #13"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "Create a type `IceShoeType` and 1 member of this type `iceShoe`\n\nall IceProducts must meet the following requirements\n\n- has readonly id field\n- has size (i.e. 7, 8, 11)\n- has a name\n- has an Optional value to describe if is the product has a wide version\n- has a description"
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "\ntype IceShoeType = {\n    readonly id: number,\n    size: number,\n    name: string,\n    wideVersion?: boolean,\n    description: string\n}\n\nlet iceShoe: IceShoeType = {\n    id: 3,\n    size: 7.5,\n    name: 'Vans',\n    description: 'My Checkered Vans. Did they come back in style? Or did they never leave? Who knows...'\n}\n\n\nconsole.log(iceShoe.description)\n"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "application/vnd.code.notebook.stdout",
                            "value": [
                                "My Checkered Vans. Did they come back in style? Or did they never leave? Who knows...",
                                ""
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "language": "markdown",
            "source": [
                "<a id=\"union\"></a>\n\n### Union Types"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "We can assign a variable multiple types, instead of just one.  This is great when the value could have multiple datatype.   This is done with the union operator `|` which is the pipe key"
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "// When we use the | to assign multiple values \nlet multipleType: string | number"
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "multipleType = 'My string!'\nmultipleType = 5"
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "multipleType = true //Error\n"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "#### Union Types with Function"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "We using a union type for parameters, one must enable a <b>type guard</b>"
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "\nfunction inchesToCM(length: string | number): number {\n    return length * 2.54 // errors!\n}\n\ninchesToCM(12)\n"
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "// Using our union types WITH Type Guarding\n\nfunction inchesToCm(length: string | number):number {\n    if (typeof length === 'string'){\n        return parseFloat(length) * 2.54\n    } else {\n        return length * 2.54\n    }\n}\n\ninchesToCm('12')\n"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "text/plain",
                            "value": [
                                "\u001b[33m30.48\u001b[39m"
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "language": "markdown",
            "source": [
                "<a id=\"ice14\"></a>\n\n## In-Class Exercise #14"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "Create a function that takes one parameter that can be either a boolean or a string.  Using a type guard have the function return back the boolean or have it return true/false if the string starts with a `\"c\" or \"C\"`\n\nBe sure to use type annonations to enforce your parameter types and the functions return type\n\nName the function `ice13`"
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "// Use Type Guarding to manage what your function does based on different types! \n\n\nfunction ice13(myParam: boolean | string): boolean {\n    if (typeof myParam === 'string'){\n        return myParam.toLowerCase().startsWith('c')\n    } else {\n        return myParam\n    }\n}\n\nice13('cheerios')\nice13(false)"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "text/plain",
                            "value": [
                                "\u001b[33mfalse\u001b[39m"
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "language": "markdown",
            "source": [
                "<a id=\"as\"></a>\n\n### As Keyword"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "The `as` keyword tells Typescript to treat a variable like its a member of a certain type.\n\nYou can solve many problems using `as any`, but this is considered bad practice and should be avoided"
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "// Reassuring TypeScript that its going to be ok... xD \n\nfunction doesInclude(arr: string[], target: string | number): boolean { // does this target exist within this array\n    return arr.includes(target) // you have an array full of strings and you want me to search through for a possible number - that won;t work\n}\n\n\n\nfunction doesInclude2(arr: string[], target: string | number): boolean { // does this target exist within this array\n    return arr.includes(target as string) // you have an array full of strings and you want me to search through for a possible number - that won;t work\n}\n\ndoesInclude(['Fire Nation', 'Water Nation', 'Earth Nation'], 'Air Nation')\ndoesInclude(['Fire Nation', 'Water Nation', 'Earth Nation'], 57)"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "text/plain",
                            "value": [
                                "\u001b[33mfalse\u001b[39m"
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "language": "markdown",
            "source": [
                "<a id=\"intersec\"></a>\n\n### Intersection Types"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "We can make new types by combining old types using an intersection and the `&`\n\n<b>Note: </b> Two types can be combined if they don't share a common key with different type.  So that means both types can have an id field as long as the id field is defined as the same type (say number) in both original classes"
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "// combine types using '&' to make an intersection type\n\ntype Moveable = {\n    id: number,\n    x: number,\n    y: number,\n    move?: () => void\n}\n\ntype Resizeable = {\n    id: number,\n    width: number,\n    height: number,\n    resize?: ()=>void\n}\n\ntype Component = Moveable & Resizeable"
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "let newComponent: Component = {\n    id: 5,\n    x: 10,\n    y: 10,\n    width: 25,\n    height: 15\n}\n\nconsole.log(newComponent.y)"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "application/vnd.code.notebook.stdout",
                            "value": [
                                "10",
                                ""
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "language": "markdown",
            "source": [
                "<a id=\"ice15\"></a>\n\n## In-Class Exercise #15"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "Create two types and then create a 3rd type from those first two type.\n\nIceUser:\n\n- firstName\n- lastName\n- age\n\nIceCustomer:\n- cart (array of strings)\n- address (string)\n\n\nIceComplete:\n- Combination of IceCustomer and IceUser\n\nAlso Create an IceComplete Object named `icedOver`\n"
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "type IceUser = {\n    firstName: string,\n    lastName: string,\n    age: number\n}\n\ntype IceCustomer = {\n    cart: string[],\n    address: string\n}\n\ntype IceComplete = IceUser & IceCustomer\n\n\nlet icedOver: IceComplete = {\n    firstName: 'Lexie',\n    lastName: 'Young',\n    age: 27,\n    cart: ['candles', 'blankets'],\n    address: '123 Real Street'\n}\n\nconsole.log(icedOver.age)"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "application/vnd.code.notebook.stdout",
                            "value": [
                                "27",
                                ""
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "language": "markdown",
            "source": [
                "<a id=\"literal\"></a>\n\n### Literal Types"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "A Literal type works kind of like an enum type.  You can set the possible values are variable takes by assigning it a value and chaining all posible values with the `|`"
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "// This is useless\n\nlet literalType: 100 // this is saying the tpye literally cannot be anyhting but 100 itself"
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "// literal union types\n\nlet multipleLiteralTypes: 100 | 50 | 25 // aka... it needs to be one of these types\nmultipleLiteralTypes = 75 // error\nmultipleLiteralTypes = 100 // OK"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "We can even define the options as its own type."
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "type Color = 'red' | 'blue' | 'green' | 'yellow'\n\nlet myColor: Color = 'green'"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "<a id=\"nnao\"></a>\n\n### Non-null assertion operator"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "The non-null assertion operator is used to postfix variables to tell TypeScript that the variable can not be null even thought TypeScript may think that it could be null.  Good practice states this should not be used when the variable could actually be null, and only when TypeScript can't infer that the null type has been ruled out\n\n\nTypeScript has a .tsconfig file (uneditabled in this jupyter notebook) that allows use to turn some of the TypeScript rules on or off (more on this later).  For the following example we want strictNullChecks option turned on (set to true)  This can not be done in this notebook, so check out this example of TypeScript Playground:\n\nhttps://www.typescriptlang.org/play?&install-plugin=@structured-types/playground-plugin#code/PTAqAsFMAIBcGcDGB7AdgMwJYHNrgIbzTySyyaq4BE8sATporAHICuANuwMJSIDW8KgC44dVpAA0AKBlT0rVE0xpoAN3ztMAE3yxIAZXKUAFDtj4A-CNoNKAHwVbIWVJC13UHdgEpoAbyloIOgQaB5IfgpcWGRiSBhYKGgzfGhMIk9OaGQ6aEdnCjdA4Mx0aFNdVIBeGuhM9mg7O2TK6BqqvNQnFzdvAOCBuHA6ZAB3OshxgFE6EbpjAHIYRHxUVGRYaAAjGHqF72KggF9i4pOg+UVyFQAHEcRIeHgp1HJYAE8K8ytieiiHLoFVzueq+frBdSaMwGIzYL74A4DUIpaArVATVSQXL4JisDTsd7bXZebK5fI9LRBQ4hYBElasEhDGB3SCqAB00EuShUo2QHEpMzm2VYsFOSLA7xuBkQDBum3SnXwW3YCViFHQWKGuha5lRqzqGyJdRJOU63UKlOpoXgsVGMBIMFSKAAtjdMOxdMp0Vi5mLgirNkQOik2TEADJjLFcQiQYy+P1W2mgWJYAAeQwVdryjMSuzQAFp6tBCCQ6Nd0cgpXRdDlE9AA8Q2jr8ABCUPICN2ujRkhxhPHYp3ZAPJ4vN6fbxAA\n\n\n"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "<a id=\"hw\"></a>\n\n# Homework"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "#### Question #1"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "Create a type to represent the following instances of `CTStudent` Also declare three 3 students below as type `CTStudent` and set their values\n\n```\nlet student1 = {\n    id: 'GMK435&g62L00',\n    name: 'John Smith',\n    age: 24,\n    isTired: true,\n    projectsCompleted:[\"HTML Portfolio\", \"Fakebook\", \"Pokemon API Project\", \"Weather Bug\"],\n    pet: 'dog'\n}\n\nlet student2= {\n    id: '6KGS%54GmlY76',\n    name: 'Jenny Hawthorne',\n    age: 28,\n    isTired: false,\n    projectsCompleted:[\"HTML Portfolio\"],\n}\n\nlet student3 = {\n    id: '6KGS%54GmlY76',\n    name: 'Neo',\n    age: 57,\n    isTired: true,\n    projectsCompleted:[\"Matrix\",\"Biological Interface Program\"],\n    pet:'cat'\n}\n```"
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "//Answer\n\ntype CTStudent = {\n    readonly id: string,\n    name: string,\n    age: number,\n    isTired: boolean,\n    projectsCompleted: string[],\n    pet?: string\n}\n\nlet student01: CTStudent = {\n    id: 'GMK435&g62L00',\n    name: 'John Smith',\n    age: 24,\n    isTired: true,\n    projectsCompleted:[\"HTML Portfolio\", \"Fakebook\", \"Pokemon API Project\", \"Weather Bug\"],\n    pet: 'dog'\n}\n\nlet student02= {\n    id: '6KGS%54GmlY76',\n    name: 'Jenny Hawthorne',\n    age: 28,\n    isTired: false,\n    projectsCompleted:[\"HTML Portfolio\"],\n}\n\nlet student03 = {\n    id: '6KGS%54GmlY76',\n    name: 'Neo',\n    age: 57,\n    isTired: true,\n    projectsCompleted:[\"Matrix\",\"Biological Interface Program\"],\n    pet:'cat'\n}\n\n\nconsole.log(student01.name)\nconsole.log(student02.isTired)\nconsole.log(student03.pet)\n"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "application/vnd.code.notebook.stdout",
                            "value": [
                                "John Smith",
                                "false",
                                "cat",
                                ""
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "language": "markdown",
            "source": [
                "#### Question #2"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "Write a function that will accept a an object of type `Fruit`, the object of type Fruit could also be `null`.  If their is a Fruit print the color of the fruit, otherwise print `You ate my fruit already` be sure to annoate the return type of the function"
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "//Given\ntype Fruit={\n    color:string,\n    shape:string\n}\n\nlet apple:Fruit={color:\"red\", shape:\"sphere\"}\n//let eaten:Fruit=null\n\nlet eaten2 = null\n\n//Answer\n\nfunction fruitFunc (param1: Fruit | null) {\n    if (typeof param1 === Fruit){\n        return param1?.color\n    } else if (typeof param1 === null) {\n        return 'You ate my fruit already'\n\n    };\n}\n\nfruitFunc(apple)\nfruitFunc(eaten2)"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "application/vnd.code.notebook.error",
                            "value": {
                                "name": "ReferenceError",
                                "message": "Fruit is not defined",
                                "stack": "    at fruitFunc (<Cell 192> [17, 15])\n    at <Cell 192> [22, 0]\n    at <Cell 192> [16, 46]\n    at Script.runInContext (node:vm:148:12)\n    at Script.runInNewContext (node:vm:153:17)\n    at Object.runInNewContext (node:vm:309:38)\n    at C (/Users/alexandriayoung/.vscode/extensions/donjayamanne.typescript-notebook-2.0.6/out/extension/server/index.js:2:113345)\n    at t.execCode (/Users/alexandriayoung/.vscode/extensions/donjayamanne.typescript-notebook-2.0.6/out/extension/server/index.js:2:114312)\n    at k.<anonymous> (/Users/alexandriayoung/.vscode/extensions/donjayamanne.typescript-notebook-2.0.6/out/extension/server/index.js:2:142156)\n    at k.emit (node:events:518:28)"
                            }
                        }
                    ]
                }
            ]
        },
        {
            "language": "markdown",
            "source": [
                "#### Question #3"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "Create a Union Type named `Ebook` for `Book` and `DigitalBook` and create one instance of the new union type"
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "//Given \ntype Book={\n    isbn:string,\n    title:string,\n    author:string\n}\n\ntype DigitalBook={\n    fileType:string,\n}\n\n//Answer\n\ntype EBook= Book & DigitalBook\n\nlet book1: EBook = {\n    isbn: 'hello',\n    title: 'world',\n    author: 'Jane Doe',\n    fileType: 'exe'\n}\n\nconsole.log(book1.title)"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "application/vnd.code.notebook.stdout",
                            "value": [
                                "world",
                                ""
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "language": "markdown",
            "source": [
                "#### Question #4"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "Create a Type to represent a `ShopItem` that will fit the following rules. You may need to create additional structures\n\n- All ShopItems have an numeric id that can not be edited \n- All ShopItems have a price\n- All ShopItems have a description\n- Some ShopItems have a color\n- All ShopItems have a Category represented with an enum \n    - Possible Categories are `Shirts` `Shoes` `Pants` `Hats`\n- All ShopItems have a list of keywords used to help search for the ShopItem \n    - For Example A Ironman Tshirt may have keywords = [\"Marvel\", \"Endgame\", \"Ironman\",\"Character Tees\", \"Tony Stark\"]\n\nAfter Creating the `ShopItem` type create 3 items using this type"
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "\nenum Category{Shirt='Tops', Shoes='Shoe', Pants='Bottoms', Hats='Hat'}\n\ntype ShopItem = {\n    readonly id: number,\n    price: number,\n    description: string,\n    color?: string,\n    category: Category,\n    keywords: string[]\n};\n\n\n\nlet item1: ShopItem = {\n    id: 1,\n    price: 5.99,\n    description: 'Hat',\n    color: 'Blue',\n    category: Category.Hats,\n    keywords: ['blue', 'hat', 'dodgers', 'baseball']\n}\n\n\nlet item2: ShopItem = {\n    id: 2,\n    price: 15.99,\n    description: 'Shirt',\n    color: 'Red',\n    category: Category.Shirt,\n    keywords: ['red', 'women\\'s', 'hockey', 'red wings']\n}\n\nlet item3: ShopItem = {\n    id: 3,\n    price: 25.99,\n    description: 'Pants',\n    color: 'Brown',\n    category: Category.Pants,\n    keywords: ['brown', 'men\\'s', 'pants']\n}\n\n\nconsole.log(item1.description)\nconsole.log(item2.price)\nconsole.log(item3.category)\n"
            ],
            "outputs": [
                {
                    "items": [
                        {
                            "mime": "application/vnd.code.notebook.stdout",
                            "value": [
                                "Hat",
                                "15.99",
                                "Bottoms",
                                ""
                            ]
                        }
                    ]
                }
            ]
        }
    ]
}